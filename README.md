Устные вопросы

1. Какой самый эффективный способ конкатенации строк?
- Использование strings.Builder
2. Что такое интерфейсы, как они применяются в Go? 
- Интерфейсы в Go позволяют определить поведение объекта. Если тип содержит реализацию всех методов интерфейса, значит он реализует этот интерфейс.
3. Чем отличаются RWMutex от Mutex?
- Mutex блокирует работу над общим ресурсом всех горутин кроме одной. 
- RWMutex может блокировать на чтение и на запись. RLock запрещает всем горутинам делать запись, в это время чтение могут выполнять любые горутины. При Lock результат аналогичен Mutex Lock.
4. Чем отличаются буферизированные и не буферизированные каналы?
- При отправлении значения в небуферизированный канал отправляющая горутина блокируется до тех пор, пока другая горутина не выполнит получение из этого канала. Верно и обратное, если горутина получает значение, она блокируется, пока значение не будет получено.
- Буферизированные каналы имеют очередь элементов. Размер очереди задается при создании канала. Операция отправления в буф. канал добавляет элемент в конец очереди. Если канал заполнен, операция отправления блокирует свою горутину, до тех пор, пока другая горутина не освободит место, получив данные из канала.
5. Какой размер у структуры struct{}{}?
- 0 байт
6. Есть ли в Go перегрузка методов или операторов?
- Нет.
7. В какой последовательности будут выведены элементы map[int]int?
    Пример:
    ```go
    m[0]=1
    m[1]=124
    m[2]=281
   ```
- Порядок не определен
8. В чем разница make и new?
- make(T, args) | new(T)
- make() работает только со slices, maps, channels
- new() работает с любыми типами
- make() возвращает указанный тип, а new() возвращает указатель на тип
- make() инициализирует память, а new() обнуляет память
9. Сколько существует способов задать переменную типа slice или map?
- 6:
    ```go
    letters := []string{}
    letters := []string{"a", "b", "c", "d"}
    var letters []string
    letters := make([]string, 0)
    letters := make([]string, 0, 10)
    letters := new([]string)
    
    var m map[string]string
    m1 := map[int]int{}
    m := map[string]string{"first": "data"}
    m := make(map[string]string)
    m := make(map[string]string, 10)

    ```
10. Что выведет данная программа и почему?
    ```go
    func update(p *int) {
        b := 2
        p = &b
    }
        
    func main() {
        var (
            a = 1
            p = &a
        )
        fmt.Println(*p)
        update(p)
        fmt.Println(*p)
    }
    ```
- Вывод:
- 1
- 1
- При передачи указателя в функцию он передается по значению. Поэтому внутри функции мы не обновим переменную из main.
11. Что выведет данная программа и почему?

    ```go
    func main() {
        wg := sync.WaitGroup{}
        for i := 0; i < 5; i++ {
            wg.Add(1)
            go func(wg sync.WaitGroup, i int) {
                fmt.Println(i)
                wg.Done()
            }(wg, i)
        }
        wg.Wait()
        fmt.Println("exit")
    }
    ```
- Возникнет deadlock. Мы передаем WaitGroup в функцию по значению, поэтому в горутине будет копия wg, и при вызове Done() у неё, не будет уменьшаться счётчик у WaitGroup в main.
12. Что выведет данная программа и почему?

    ```go
    func main() {
        n := 0
        if true {
            n := 1
            n++
        }
        fmt.Println(n)
    }
    ```
- 0
- Так как в if другая область видимости, переменная n, созданная внутри неё, будет инкрементирована и видна только в этой области видимости.
13. Что выведет данная программа и почему?

    ```go
    func someAction(v []int8, b int8) {
        v[0] = 100
        v = append(v, b)
    }
    
    func main() {
        var a = []int8{1, 2, 3, 4, 5}
        someAction(a, 6)
        fmt.Println(a)
    }
    ```
- [100 2 3 4 5]
- Слайс содержит в указатель на массив. Передавая слайс в функцию по значению, он копируется, но указатель на массив остается тот же. Поэтому мы можем изменить значения элементов массива. Функция append добавляет элементы в слайс и возвращает новый. Так как слайс передан по значению, изменений после append в main мы не увидим.
14. Что выведет данная программа и почему?

    ```go
    func main() {
        slice := []string{"a", "a"}
    
        func(slice []string) {
            slice = append(slice, "a")
            slice[0] = "b"
            slice[1] = "b"
            fmt.Print(slice)
        }(slice)
        fmt.Print(slice)
    }
    ```
- [b b a][a a]
- append возвращает новый слайс, поэтому изменяя элементы в нём, это не будет отражаться в исходном слайсе.
